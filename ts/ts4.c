

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <linux/fb.h>
#include <linux/input.h>
#include <sys/mman.h>

#define FBDEVFILE "/dev/fb2"
#define EVENTFILE "/dev/input/event4"

#define BUTTON_XSIZE 40
#define BUTTON_YSIZE 25

#define COLOR_SIZE 20
#define PAPER_SIZE 200

typedef unsigned char ubyte;

typedef struct tag_point
{
	int x;
	int y;
}point;

typedef struct tag_datablock
{
	int fd;
	int fbfd;
	struct fb_var_screeninfo fbvar;
	unsigned short* pfbdata;
}datablock;

typedef struct tag_input
{
	int x;
	int y;
	int pressure;
}input;

typedef struct tag_paint
{	
	int center_x, center_y;
}paint;

void init();
input readtouch();
int readcommand(input);
void setcolor(int);
void setdrawmode(int);
void setpenmode(int);
unsigned short makepixel(ubyte, ubyte, ubyte);

const unsigned char IMG_line[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfd,0xfe,0xff,0xff,0xff,0xfd,0xff,0xff,0xff,0xff,0xfd,0xff,0xff,0xf8,0x7f,0xfd,0xfe,0xe8,0xf3,0x3f,0xfd,0xfe,0xea,0x77,0xbf,0xfd,0xfe,0xe3,0x77,0xbf,0xfd,0xfe,0xf7,0x30,0x3f,0xfd,0xfe,0xf7,0xb7,0xff,0xfd,0xff,0x77,0xb7,0xff,0xfe,0xff,0x77,0xb3,0xdf,0xfe,0x07,0x7f,0xf8,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_rect[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xbf,0xff,0xff,0xff,0xfe,0x4f,0xff,0xff,0xff,0xfe,0x77,0xff,0xff,0xff,0xfe,0xf3,0xff,0xff,0xbf,0xfe,0xfb,0xff,0xff,0xbf,0xfe,0xf3,0x8f,0xe3,0xbf,0xfe,0xf7,0x33,0xdb,0xbf,0xfe,0xef,0x7b,0xbe,0x07,0xfe,0x9e,0x73,0xbf,0xbf,0xfe,0x1e,0x07,0xbf,0xbf,0xfe,0xe7,0x7f,0xbf,0xbf,0xfe,0xf3,0x3d,0x9f,0xbf,0xfe,0xf9,0x83,0xc1,0xc1,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
const unsigned char IMG_oval[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x1f,0xff,0xfe,0xff,0xf8,0x1f,0xff,0xfe,0xff,0xf2,0xef,0xff,0xfe,0xff,0xf7,0xe7,0xff,0xff,0x7f,0xef,0xf5,0xef,0xff,0x7f,0xef,0xf5,0xe8,0x3f,0x7f,0xef,0xf6,0xdb,0x9f,0x7f,0xf7,0xf6,0xdb,0x9f,0x7f,0xf7,0xf6,0x5b,0x8f,0x7f,0xf7,0xef,0x1b,0xa7,0x7f,0xfb,0xcf,0x3c,0x77,0x7f,0xfc,0x1f,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_freedraw[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x7f,0xff,0xff,0xff,0xcf,0xff,0xff,0xff,0xff,0xef,0xdf,0xff,0xff,0xff,0xe0,0xde,0x30,0x7f,0xff,0xef,0xc2,0x97,0x7f,0xff,0xef,0xde,0x30,0x7f,0xff,0xef,0xde,0xf3,0xff,0xff,0xff,0xde,0x19,0x7f,0xff,0xff,0xff,0x3c,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xff,0xff,0xff,0xff,0xef,0xff,0xff,0xff,0xff,0xed,0xcf,0xff,0xff,0xff,0xec,0x87,0xf7,0xef,0xff,0xee,0x3c,0x76,0xef,0xff,0x0e,0x7d,0x32,0x5f,0xff,0x4f,0x7d,0x1a,0x5f,0xff,0x6f,0x7c,0x59,0x1f,0xff,0x07,0x7f,0xcd,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_select[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x7f,0xcf,0xff,0xff,0xf9,0x3f,0xdf,0xff,0xff,0xfb,0xff,0xcf,0xff,0xff,0xf7,0xff,0xef,0xff,0x9f,0xf7,0xff,0xef,0xff,0xdf,0xf7,0xf9,0xef,0xff,0xdf,0xfb,0xf0,0xec,0x39,0x03,0xfc,0xf6,0x69,0xb0,0xdf,0xfe,0x77,0x69,0x27,0xdf,0xff,0x30,0xe8,0x6f,0xdf,0xff,0xb7,0xeb,0xe7,0xdf,0xff,0x33,0x69,0xb0,0xdf,0xf8,0x78,0x6c,0x39,0xc3,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_erase[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x3f,0xff,0xff,0xff,0xef,0xff,0xff,0xff,0xff,0xcf,0xff,0xff,0xff,0xff,0xdf,0xff,0xff,0xff,0xff,0xdf,0xff,0xff,0xff,0xff,0xdf,0xef,0xff,0xff,0xff,0xc0,0xe6,0x3f,0xf3,0x87,0xef,0xf4,0xa1,0xe5,0x73,0xef,0xf1,0xed,0xef,0x7b,0xef,0xf3,0xec,0xe7,0x33,0xef,0xf3,0xec,0xf9,0x07,0xe7,0xfb,0xed,0x7d,0x7f,0xf0,0x3b,0xf1,0x2d,0x3d,0xff,0xff,0xff,0xf3,0x93,0xff,0xff,0xff,0xff,0xc7,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_clear[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0xff,0xff,0xff,0xfc,0x7b,0xff,0xff,0xff,0xf3,0x3b,0xff,0xff,0xff,0xf7,0xfb,0xff,0xff,0xff,0xef,0xfb,0xff,0xff,0xff,0xcf,0xfb,0xff,0xfe,0xff,0xdf,0xfb,0xc3,0x0e,0x67,0xdf,0xf9,0x99,0x6f,0x43,0xdf,0xfd,0x33,0x67,0x1f,0xcf,0xfd,0x07,0x73,0x3f,0xef,0xfd,0x3f,0x73,0x7f,0xf7,0xfd,0xbf,0x31,0x7f,0xf0,0x7d,0x9f,0x85,0x7f,0xff,0xfd,0xe1,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_pen[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x1f,0xff,0xff,0xff,0xfc,0xc7,0xff,0xff,0xff,0xfe,0xfb,0xff,0xff,0xff,0xfe,0xfb,0xff,0xff,0xff,0xfe,0xfb,0xff,0xff,0xff,0xfe,0xfb,0xc1,0xff,0xff,0xfe,0xfb,0x9e,0xd8,0x7f,0xfe,0xf7,0x7e,0xd3,0x3f,0xfe,0x0f,0x7c,0xd7,0xbf,0xfe,0xff,0x79,0xd7,0xbf,0xfe,0xff,0x07,0xc7,0xbf,0xfe,0xff,0x7f,0xef,0xdf,0xfe,0xff,0x7f,0xef,0xdf,0xfe,0xff,0x3f,0xef,0xdf,0xfe,0xff,0x91,0xef,0xff,0xfe,0xff,0xe7,0xff,0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
const unsigned char IMG_fill[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x07,0x7d,0xef,0xff,0xfc,0xff,0x7d,0xef,0xff,0xfe,0xff,0xfd,0xef,0xff,0xfe,0xff,0xfd,0xef,0xff,0xfe,0xff,0xbd,0xef,0xff,0xfe,0xff,0xbd,0xef,0xff,0xfe,0x07,0xbd,0xef,0xff,0xfe,0xff,0xbd,0xef,0xff,0xfe,0xff,0xbd,0xef,0xff,0xfe,0xff,0xbd,0xef,0xff,0xfe,0xff,0xbd,0xe7,0xff,0xfe,0xff,0xbd,0xf7,0xff,0xfe,0xff,0xbe,0xf7,0xff,0xfe,0xff,0xbe,0xfb,0xff,0xff,0xff,0xbf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 

const point line_pos = {10,20};
const point rect_pos = {10,50};
const point oval_pos = {10,80};
const point freedraw_pos = {10,110};
const point select_pos = {10,140};
const point erase_pos = {10,170};
const point clear_pos = {10,200};
const point pen_pos = {270,160};
const point fill_pos = {270,200};
const point white_pos = {265,20};
const point orange_pos = {295,20};
const point red_pos = {265,50};
const point green_pos = {295,50};
const point yellow_pos = {265,80};
const point navy_pos = {295,80};
const point blue_pos = {265,110};
const point black_pos = {295,110};
const point paper_pos = {60,20};

double K;
double A;
double B;
double C;
double D;
double E;
double F;

datablock db;

unsigned char background[160][240];
unsigned short colors[8];

int drawmode;
int penmode;
int current_color; 

int main()
{
	init();
	input ip;
	
	int i, j, k;
	int prev_pressure = 0;
	struct input_event ie;

	int offset, px;
	int cmd;

	while(1)
	{
		ip = readtouch();
		cmd = readcommand(ip);
		

		if(cmd>=0 && cmd<=5)			// set drawmode
			setdrawmode(cmd);
		else if(cmd == 6)			// clear
			printf("%d\n",cmd);
		else if(cmd == 10 || cmd == 11)		// pen or fill
			setpenmode(cmd);
		else if(cmd>=20 && cmd<=27)		// colors
			setcolor(cmd);
		else if(cmd==100);			// drawing
	}
	/*
	px = makepixel(0,0,0);

	while(1)
	{
		ip = readtouch();		
			
		if(ip.x>=3 && ip.x<317 && ip.y>=3 && ip.y<237 && ip.pressure != 0)
		{
			for(i=ip.y-1; i<ip.y+2; i++)
			{
				for(j=ip.x-1; j<ip.x+2; j++)
				{
					offset = j + i*db.fbvar.xres;
					*(db.pfbdata+offset) = px;
				}
			}
		}
		
		prev_pressure = ip.pressure;
	}
	*/
	munmap(db.pfbdata, db.fbvar.xres*db.fbvar.yres*(16/8));
	close(db.fd);
	close(db.fbfd);
	return 0;
}

void init()
{	
	int fd, fbfd;
	struct input_event ie;
	int xpos1, xpos2, ypos1, ypos2;
	int ret, t;
	struct fb_var_screeninfo fbvar;
	int bg, px;

	int offset, i, j, k;
	unsigned short* pfbdata;

	int x, y, pressure = 0, prev_pressure = 0;	
	int lcd_x[3] = {100, 300, 250};
	int lcd_y[3] = {100, 200, 50};
	int ts_x[3] = {0};
	int ts_y[3] = {0};

	const unsigned char* func[9] = {IMG_line, IMG_rect, IMG_oval, IMG_freedraw, IMG_select, IMG_erase, IMG_clear, IMG_pen, IMG_fill};

	fbfd = open(FBDEVFILE, O_RDWR);
	if(fbfd < 0)
	{
		perror("fbdev open");
		exit(1);
	}

	ret = ioctl(fbfd, FBIOGET_VSCREENINFO, &fbvar);
	if(ret < 0)
	{
		perror("fbdev ioctl");
		exit(1);
	}

	if(fbvar.bits_per_pixel != 16)
	{
		fprintf(stderr, "bpp is not 16\n");
		exit(1);
	}

	pfbdata = (unsigned short*)mmap(0, fbvar.xres*fbvar.yres*(16/8), PROT_READ|PROT_WRITE, MAP_SHARED, fbfd, 0);
        if((unsigned)pfbdata == (unsigned)(-1))
        {
                perror("fbdev mmap");
                exit(1);
        }
	
	fd = open(EVENTFILE, O_RDONLY);
	if(fd < 0)
		exit(1);
	
	bg = makepixel(34, 177, 76);
	for(i=0; i<fbvar.yres; i++)
        {
                for(j=0; j<fbvar.xres; j++)
                {
                        offset = j + i*fbvar.xres;
                        *(pfbdata+offset) = bg;
                }
        }


	px = makepixel(0,0,0);
	
	for(j=lcd_y[0]-3; j<lcd_y[0]+3; j++)
	{
		for(k=lcd_x[0]-3; k<lcd_x[0]+3; k++)
		{
			 offset = j*fbvar.xres + k;
			 *(pfbdata+offset) = px;
		}
	}

	i = 0;
	while(1)
	{
                prev_pressure = pressure;

		read(fd, &ie, sizeof(struct input_event));
		if(ie.type==3)
		{
			if(ie.code==0)
				x = ie.value;
			else if(ie.code==1)
				y = ie.value;
			else if(ie.code==24)
				pressure = ie.value;
		}
	

                if(prev_pressure>0 && pressure==0)
                {
			for(j=lcd_y[i]-3; j<lcd_y[i]+3; j++)
			{
				for(k=lcd_x[i]-3; k<lcd_x[i]+3; k++)
				{
				 	offset = j*fbvar.xres + k;
					*(pfbdata+offset) = bg;
				}
			}

                        ts_x[i] = x;
                        ts_y[i] = y;
                        i++;

                        if(i==3)
                                break;
          
			for(j=lcd_y[i]-3; j<lcd_y[i]+3; j++)
			{
				for(k=lcd_x[i]-3; k<lcd_x[i]+3; k++)
				{
				 	offset = j*fbvar.xres + k;
					*(pfbdata+offset) = px;
				}
			}
		}
		printf("x = %d, y = %d, pressure = %d, prev_pressure = %d, i = %d\n", x, y, pressure, prev_pressure, i);
        }

	K = (ts_x[0] - ts_x[2])*(ts_y[1] - ts_y[2]) - (ts_x[1] - ts_x[2])*(ts_y[0] - ts_y[2]);
        A = ((lcd_x[0] - lcd_x[2])*(ts_y[1] - ts_y[2]) - (lcd_x[1] - lcd_x[2])*(ts_y[0] - ts_y[2]))/K;
        B = ((ts_x[0] - ts_x[2])*(lcd_x[1] - lcd_x[2]) - (lcd_x[0] - lcd_x[2])*(ts_x[1] - ts_x[2]))/K;
        C = (ts_y[0]*(ts_x[2]*lcd_x[1] - ts_x[1]*lcd_x[2]) + ts_y[1]*(ts_x[0]*lcd_x[2] - ts_x[2]*lcd_x[0]) + ts_y[2]*(ts_x[1]*lcd_x[0] - ts_x[0]*lcd_x[1]))/K;
        D = ((lcd_y[0] - lcd_y[2])*(ts_y[1] - ts_y[2]) - (lcd_y[1] - lcd_y[2])*(ts_y[0] - ts_y[2]))/K;
        E = ((ts_x[0] - ts_x[2])*(lcd_y[1] - lcd_y[2]) - (lcd_y[0] - lcd_y[2])*(ts_x[1] - ts_x[2]))/K;
        F = (ts_y[0]*(ts_x[2]*lcd_y[1] - ts_x[1]*lcd_y[2]) + ts_y[1]*(ts_x[0]*lcd_y[2] - ts_x[2]*lcd_y[0]) + ts_y[2]*(ts_x[1]*lcd_y[0] - ts_x[0]*lcd_y[1]))/K;

	printf("K = %lf, A = %lf, B = %lf, C = %lf, D = %lf, E = %lf, F = %lf\n", K, A, B, C, D, E, F);
        printf("%lf, %lf\n", A*1300+B*2400+C, D*1300+E*2400+F);

	colors[0] = makepixel(255,255,255);
	colors[1] = makepixel(255,127,39);
	colors[2] = makepixel(237,28,36);
	colors[3] = makepixel(181,230,29);
	colors[4] = makepixel(255,242,0);
	colors[5] = makepixel(63,72,204);
	colors[6] = makepixel(0,162,232);
	colors[7] = makepixel(0,0,0);

	x = 10;
	y = 20;

	px = makepixel(0,0,0);
	bg = makepixel(255,255,255);
	
	for(k=0; k<7; k++)
	{
		for(i=0; i<BUTTON_YSIZE; i++)
		{
			for(j=0; j<5; j++)
			{
				unsigned char bits = func[k][j+i*5];
				unsigned char bit = 0x80;
				for(t=0; t<8; t++)
				{
					offset = (x+t+j*8) + (y+i)*fbvar.xres;
					if((bits&bit)==bit)
						*(pfbdata+offset) = bg;
					else
						*(pfbdata+offset) = px;
					bit = bit>>1;
				}
			}
		}
		y = y + BUTTON_YSIZE + 5;
	}

	x = 270;
	y = 160;
	
	for(k=7; k<9; k++)
	{
		for(i=0; i<BUTTON_YSIZE; i++)
		{
			for(j=0; j<5; j++)
			{
				unsigned char bits = func[k][j+i*5];
				unsigned char bit = 0x80;
				for(t=0; t<8; t++)
				{
					offset = (x+t+j*8) + (y+i)*fbvar.xres;
					if((bits&bit)==bit)
						*(pfbdata+offset) = bg;
					else
						*(pfbdata+offset) = px;
					bit = bit>>1;
				}
			}
		}
		y = y + BUTTON_YSIZE + 15;
	}

	x = 60;
	y = 20;

	px = bg;

	for(i=y; i<y+PAPER_SIZE; i++)
	{
		offset = i*fbvar.xres;
		for(j=x; j<x+PAPER_SIZE; j++)
			*(pfbdata+offset+j) = px;
	}
	
	x = 265;
	y = 20;
	t = 0;
	
	for(k=0; k<4; k++)
	{
		for(i=y; i<y+COLOR_SIZE; i++)
		{
			offset = i*fbvar.xres;
			for(j=x; j<x+COLOR_SIZE; j++)
				*(pfbdata+offset+j) = colors[t];
		}
		t++;
		for(i=y; i<y+COLOR_SIZE; i++)
		{
			offset = i*fbvar.xres;
			for(j=x+30; j<x+30+COLOR_SIZE; j++)
				*(pfbdata+offset+j) = colors[t];
		}
		t++;
		y = y + 30;
	}

	drawmode = 3;
	penmode = 1;
	current_color = colors[7];

	db.fd = fd;
	db.fbfd = fbfd;
	db.fbvar = fbvar;
	db.pfbdata = pfbdata;
}

input readtouch()
{
	static int x = 0, y = 0;
	static int pressure = 0;
	struct input_event ie;

	input new;
	
	read(db.fd, &ie, sizeof(struct input_event));
	if(ie.type==3)
	{
		if(ie.code==0)
			x = ie.value;
		else if(ie.code==1)
			y = ie.value;
		else if(ie.code==24)
			pressure = ie.value;
	}
	
	new.x = (int)(A*x+B*y+C);
	new.y = (int)(D*x+E*y+F);
	new.pressure = pressure;
	
	return new;
}

int readcommand(input ip)
{
	int x = ip.x;
	int y = ip.y;
	int pressure = ip.pressure;
	static int prev_pressure = 0;
		
	int cmd;
	
	if(prev_pressure>0 && pressure==0)
	{
		if(x>=line_pos.x && x<line_pos.x+BUTTON_XSIZE)
		{
			if(y>=line_pos.y && y<line_pos.y+BUTTON_YSIZE)
				cmd = 0;
			else if(y>=rect_pos.y && y<rect_pos.y+BUTTON_YSIZE)
				cmd = 1;
			else if(y>=oval_pos.y && y<oval_pos.y+BUTTON_YSIZE)
				cmd = 2;
			else if(y>=freedraw_pos.y && y<freedraw_pos.y+BUTTON_YSIZE)
				cmd = 3;
			else if(y>=select_pos.y && y<select_pos.y+BUTTON_YSIZE)
				cmd = 4;
			else if(y>=erase_pos.y && y<erase_pos.y+BUTTON_YSIZE)
				cmd = 5;
			else if(y>=clear_pos.y && y<clear_pos.y+BUTTON_YSIZE)
				cmd = 6;
			else
				cmd = -1;
		}
		else if(x>=white_pos.x && x<orange_pos.x+COLOR_SIZE)
		{
			if(y>=pen_pos.y && y<pen_pos.y+BUTTON_YSIZE)
				cmd = 10;	
			else if(y>=fill_pos.y && y<fill_pos.y+BUTTON_YSIZE)
				cmd = 11;
			else
			{
				if(y>=white_pos.y && y<white_pos.y+COLOR_SIZE)
				{
					if(x<white_pos.x+COLOR_SIZE)
						cmd = 20;
					else if(x>=orange_pos.x)
						cmd = 21;
					else
						cmd = -1;
				}
				else if(y>=red_pos.y && y<red_pos.y+COLOR_SIZE)
				{
					if(x<white_pos.x+COLOR_SIZE)
						cmd = 22;
					else if(x>=orange_pos.x)
						cmd = 23;
					else
						cmd = -1;
				}
				else if(y>=yellow_pos.y && y<yellow_pos.y+COLOR_SIZE)
				{
					if(x<white_pos.x+COLOR_SIZE)
						cmd = 24;
					else if(x>=orange_pos.x)
						cmd = 25;
					else
						cmd = -1;
				}
				else if(y>=blue_pos.y && y<blue_pos.y+COLOR_SIZE)
				{
					if(x<white_pos.x+COLOR_SIZE)
						cmd = 26;
					else if(x>=orange_pos.x)
						cmd = 27;
					else
						cmd = -1;
				}
				else
					cmd = -1;
			}
		}
		else
			cmd = -1;
	}
	else
	{
		if(x>=paper_pos.x && x<paper_pos.x+PAPER_SIZE && y>=paper_pos.y && y<paper_pos.y+PAPER_SIZE)
			cmd = 100;
		else
			cmd = -1;
	}
	
	prev_pressure = pressure;
	return cmd;	
}

void setcolor(int cmd)
{
	current_color = colors[cmd-20];
}

void setdrawmode(int cmd)
{
	drawmode = cmd;
}

void setpenmode(int cmd)
{
	penmode = cmd - 10;
}

unsigned short makepixel(ubyte r, ubyte g, ubyte b)
{
        return (((r>>3)<<11) | ((g>>2)<<5) | (b>>3));
}
